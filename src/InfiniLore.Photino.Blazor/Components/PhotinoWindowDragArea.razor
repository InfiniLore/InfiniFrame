@using InfiniLore.Photino.NET
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using System.Drawing

@namespace InfiniLore.Photino.Blazor

@inherits ComponentBase
@implements IDisposable

@inject IJSRuntime JsRuntime
@inject IPhotinoWindow PhotinoWindow

@* ReSharper disable CSharpWarnings::CS8974 *@
<div
    @ref="_dragArea"
    onpointerdown:preventDefault
    ondblclick="@OnDoubleClick"
    onpointerdown="@OnPointerDown"
    onpointerup="@OnPointerUp"
    onpointermove="@OnPointerMove"
    @attributes="ExtraAttributes"
>
    @* ReSharper restore CSharpWarnings::CS8974 *@
    @ChildContent
</div>

@code {
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter(CaptureUnmatchedValues = true)] public Dictionary<string, object>? ExtraAttributes { get; set; }
    
    private ElementReference _dragArea;

    private bool _isGrabbing;
    private bool _suppressRender;
    private bool _suppressGrabbing; // TEMP solution to fix a bug with dragging after returning from maximized state.
    private long _lastKnownPointerId;

    // ReSharper disable once InvertIf
    protected override bool ShouldRender() {
        if (!base.ShouldRender()) return false;
        
        // Reset every time to ensure we don't render until we're ready.
        if (_suppressRender) {
            _suppressRender = false;
            return false;
        }
        return true;
    }

    protected override void OnInitialized() {
        base.OnInitialized();

        PhotinoWindow.Events.WindowMaximized += OnMaximized;
        PhotinoWindow.Events.WindowRestored += OnRestored;
    }

    public void Dispose() {
        PhotinoWindow.Events.WindowMaximized -= OnMaximized;
        PhotinoWindow.Events.WindowRestored -= OnRestored;
    }

    private void OnMaximized(object? sender, EventArgs eventArgs) {
        _suppressGrabbing = true;
    }
    
    private void OnRestored(object? sender, EventArgs eventArgs) {
        _suppressGrabbing = false;
    }

    private async Task OnPointerDown(PointerEventArgs args) {
        _suppressRender = true;
        if (_suppressGrabbing) return;
        _isGrabbing = true;
        
        if (PhotinoWindow.CachedPreMaximizedBounds != Rectangle.Empty) {
            Rectangle bounds = PhotinoWindow.CachedPreMaximizedBounds;
            PhotinoWindow.CachedPreMaximizedBounds = Rectangle.Empty;
            
            PhotinoWindow.Invoke(() => {
                int targetX = (int)(args.ScreenX - bounds.Width / 2f);
                int targetY = (int)(args.ScreenY - 10);
                PhotinoNative.SetSize(PhotinoWindow.InstanceHandle, bounds.Width, bounds.Height);
                PhotinoNative.SetPosition(PhotinoWindow.InstanceHandle, targetX, targetY);
            });
        }

        _lastKnownPointerId = args.PointerId;
        await JsRuntime.InvokeVoidAsync("setPointerCapture", _dragArea, args.PointerId);
    }

    private async Task OnPointerUp(PointerEventArgs args) {
        _suppressRender = true;
        if (_suppressGrabbing) return;
        _isGrabbing = false;
        await JsRuntime.InvokeVoidAsync("releasePointerCapture", _dragArea, args.PointerId);
        _lastKnownPointerId = 0;
    }


    private async Task OnDoubleClick(MouseEventArgs args) {
        _suppressRender = true;
        _isGrabbing = false;
        PhotinoWindow.ToggleMaximized();
        if (_lastKnownPointerId == 0) return;
        try {
            await JsRuntime.InvokeVoidAsync("releasePointerCapture", _dragArea, _lastKnownPointerId);
        }
        catch (Exception) {
            // ignore
        }
    }

    private void OnPointerMove(PointerEventArgs args) {
        _suppressRender = true;
        if (_suppressGrabbing) return;
        if (!_isGrabbing) return;

        PhotinoWindow.Offset(args.MovementX, args.MovementY);
    }
}

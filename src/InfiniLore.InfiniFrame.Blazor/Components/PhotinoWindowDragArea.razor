@using InfiniLore.Photino.Js
@using InfiniLore.InfiniFrame.NET
@using Microsoft.AspNetCore.Components.Web
@using System.Drawing
@using PhotinoNative=InfiniLore.Photino.Native.PhotinoNative

@namespace InfiniLore.Photino.Blazor

@inherits ComponentBase
@implements IDisposable

@inject IPhotinoWindow PhotinoWindow
@inject IInfiniWindowJs InfiniWindowJs

@* ReSharper disable CSharpWarnings::CS8974 *@
<div
    @ref="_dragArea"
    onpointerdown:preventDefault
    ondblclick="@OnDoubleClick"
    onpointerdown="@OnPointerDown"
    onpointerup="@OnPointerUp"
    onpointermove="@OnPointerMove"
    @attributes="ExtraAttributes"
>
    @* ReSharper restore CSharpWarnings::CS8974 *@
    @ChildContent
</div>

@code {
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter(CaptureUnmatchedValues = true)] public Dictionary<string, object>? ExtraAttributes { get; set; }

    private ElementReference _dragArea;

    private bool _isGrabbing;
    private bool _suppressRender;
    private bool _suppressGrabbing;// TEMP solution to fix a bug with dragging after returning from maximized state.
    private long _lastKnownPointerId;

    // ReSharper disable once InvertIf
    protected override bool ShouldRender() {
        if (!base.ShouldRender()) return false;

        // Reset every time to ensure we don't render until we're ready.
        if (_suppressRender) {
            _suppressRender = false;
            return false;
        }
        return true;
    }

    protected override void OnInitialized() {
        base.OnInitialized();

        PhotinoWindow.Events.WindowMaximized += OnMaximized;
        PhotinoWindow.Events.WindowRestored += OnRestored;
    }

    public void Dispose() {
        PhotinoWindow.Events.WindowMaximized -= OnMaximized;
        PhotinoWindow.Events.WindowRestored -= OnRestored;
    }

    private void OnMaximized(object? sender, EventArgs eventArgs) {
        _suppressGrabbing = true;
    }

    private void OnRestored(object? sender, EventArgs eventArgs) {
        _suppressGrabbing = false;
    }

    private async Task OnPointerDown(PointerEventArgs args) {
        _suppressRender = true;
        if (_suppressGrabbing) return;

        _isGrabbing = true;

        if (PhotinoWindow.CachedPreMaximizedBounds != Rectangle.Empty) {
            Rectangle bounds = PhotinoWindow.CachedPreMaximizedBounds;
            PhotinoWindow.CachedPreMaximizedBounds = Rectangle.Empty;

            PhotinoWindow.Invoke(() => {
                int targetX = (int)(args.ScreenX - bounds.Width / 2f);
                int targetY = (int)(args.ScreenY - 10);
                PhotinoNative.SetSize(PhotinoWindow.InstanceHandle, bounds.Width, bounds.Height);
                PhotinoNative.SetPosition(PhotinoWindow.InstanceHandle, targetX, targetY);
            });
        }

        _lastKnownPointerId = args.PointerId;
        await InfiniWindowJs.SetPointerCaptureAsync(_dragArea, args.PointerId);
    }

    private async Task OnPointerUp(PointerEventArgs args) {
        _suppressRender = true;
        if (_suppressGrabbing) return;

        _isGrabbing = false;
        await InfiniWindowJs.ReleasePointerCaptureAsync(_dragArea, args.PointerId);
        _lastKnownPointerId = 0;
    }


    private async Task OnDoubleClick(MouseEventArgs args) {
        _suppressRender = true;
        _isGrabbing = false;
        PhotinoWindow.ToggleMaximized();
        if (_lastKnownPointerId == 0) return;

        await InfiniWindowJs.ReleasePointerCaptureAsync(_dragArea, _lastKnownPointerId);
    }

    private void OnPointerMove(PointerEventArgs args) {
        _suppressRender = true;
        if (_suppressGrabbing) return;
        if (!_isGrabbing) return;

        PhotinoWindow.Offset(args.MovementX, args.MovementY);
    }
}
